% Generated by roxygen2 (4.0.2): do not edit by hand
\name{match_call}
\alias{match_call}
\title{Match Closure Arguments To Formals}
\usage{
match_call(n = 1L, dots = "expand", default.formals = FALSE,
  empty.formals = FALSE, eval.formals = FALSE, user.formals = TRUE)
}
\arguments{
\item{n}{integer(1L) how many frames to look up the call stack, analogous to
the \code{`n`} parameter for \code{`\link{sys.parent}`}.}

\item{dots}{character(1L) "exclude": do not include dots, "include": include
them, "expand": include and expand (note last two only include dots if
there are actually args matched by dots)}

\item{default.formals}{set to TRUE to include formals not specified in call
though under no circumstances will it return ellipses even if you do
something like \code{function(a, ...=list(1, 2, 3))} which oddly R appears
to tolerate in closure definitions.}

\item{empty.formals}{set to TRUE to include formals that were not specified
and do not have default values}

\item{eval.formals}{set to TRUE if you want the argument values to be
evaluated (defaults in invoking function body, rest in parent of invoking
function).  Note it is the argument expression that is evaluated, not the
argument itself.  This should only make a difference in functions where
the argument is modified in the function body before \code{`match_call`}
is invoked (this will return the original expression, not the modified one).}

\item{user.formals}{set to FALSE if you want to exclude arguments that the
user specified; this should almost never be needed unless you specifically
want to know what arguments are using default values}
}
\value{
the call that invoked the function match_call() is invoked from (as a
  list if `eval.formals`==TRUE)
}
\description{
Similar to \code{`\link{match.call}`}, but is designed specifically to match
calls from the dynamic call stack.  Which call is matched is controlled by the
\code{`n`} argument, which is analgous to the \code{`n`} argument
for \code{`\link{sys.parent}`}.
}
\details{
You can also use \code{`match.call`} to match arbitrary calls from the
call stack, but it is simpler to do so using \code{`match_call`}.  See examples
for illustration of differences between \code{`\link{match.call}`} and
\code{`match_call`}.  Additionally, there are some corner cases where
\code{`\link{match.call}`} does not behave as expected (see vignette).
}
\examples{
# Compare `match.call` and `match_call`
fun1 <- function(a, b) {
  cat("**Matching Parent Call**\\n")
  print(match.call())
  print(match_call())

  cat("\\n**Matching Grand-Parent Call**\\n")
  print(match.call(fun2, sys.call(sys.parent())))
  print(match_call(2))
}
fun2 <- function(c, d) fun1(a + 1, b - 1)
fun2(25, pi() + 3)
# Other examples
fun <- function(a, b, c=TRUE, ...) {
  match_call(default.formals=TRUE, dots="include")
}
fun(5, 6, x=list(1:10, FALSE))
}

